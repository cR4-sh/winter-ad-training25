# PickMe House
## Базовый сценарий
Веб-приложение для шифрования данных с тремя уровнями безопасности. Пользователь может шифровать и расшифровывать данные, а также просматривать записи по ID.

### Все фичи
- Регистрация и авторизация
- Шифрование данных на трёх уровнях безопасности
- Расшифровка данных
- Просмотр записей по ID
- Профиль пользователя с биографией

## Архитектура
Flask веб-приложение с SQLite базой данных. Используется кастомный модуль SKZI для шифрования на разных уровнях.

## Уязвимости

### Предсказуемый ключ сессии

Ключ сессии генерируется детерминистически на основе глобального счётчика, который увеличивается при каждом вызове. Это позволяет предсказать ключи сессий.

```python
_counter = 0

def generate_secure_key(length=24):
    global _counter
    p_outer = 127
    p_middle = 251
    p_inner = 97
    
    g_outer = 3
    g_middle = 5
    g_inner = 6
    
    cycle_pos = _counter % 100
    _counter += 1
    
    key_bytes = []
    for i in range(length):
        inner_base = (cycle_pos * 7 + i * 13) % (p_inner - 1)
        inner_val = pow(g_inner, inner_base, p_inner)
        # ... детерминистическая генерация
    return bytes(key_bytes)
```

При старте приложения ключ генерируется один раз:
```python
app.secret_key = SKZI.generate_secure_key(24)
```

Если злоумышленник знает, сколько раз вызывалась функция до старта приложения, он может вычислить ключ сессии.

### Слабое шифрование уровня 1 (SEA)

Шифрование уровня 1 использует кастомный алгоритм SEA. Ключи генерируются на основе хеша открытого текста, что делает их предсказуемыми. Также используется небольшое простое число P=1997, что позволяет перебрать все возможные значения.

```python
def keygen(self, plaintext_bytes):
    sec_exp = random.getrandbits(256)
    key_base = pow(self.g, sec_exp, self.P)
    
    S = int.from_bytes(sha256(plaintext_bytes).digest()[:2], 'big')
    token = pow(self.h, S, self.P)
    
    internal_kb = (key_base + S) % self.P
    
    k1 = (internal_kb * self.A + self.B) & 0xFFFFFFFFFFFFFFFF
    k2 = (internal_kb * self.C + self.D) & 0xFFFFFFFFFFFFFFFF
    k1 |= 1
    
    return (k1, k2), token, key_base
```

Зная token, можно найти S через дискретный логарифм по малому модулю, а затем перебрать все возможные internal_kb (от 0 до P-1) для подбора ключей.

### Утечка ключа шифрования уровня 2

При шифровании на уровне 2 ключ показывается пользователю в ответе. Это позволяет расшифровать любые данные, зашифрованные на этом уровне.

```python
def encryption_security_clearance_level_2(plaintext: bytes, username: str = None) -> str:
    ctr = Counter.new(64, prefix=NONCE)
    cipher = AES.new(KEY, AES.MODE_CTR, counter=ctr)
    
    ciphertext = cipher.encrypt(plaintext)
    ct_hex = ciphertext.hex()
    key_hex = KEY.hex()  # Ключ показывается пользователю!
    nonce_hex = NONCE.hex()
    # ...
    return ct_hex, key_hex, nonce_hex, rec_id
```

### Атака Винера на RSA уровня 3

При шифровании на уровне 3 используется RSA с маленьким приватным ключом d (256 бит), что делает возможной атаку Винера.

```python
def encryption_security_clearance_level_3(plaintext: bytes, username: str = None) -> int:
    plaintext = bytes_to_long(plaintext)
    p = getPrime(1024)
    q = getPrime(1024)
    n = p * q
    
    phi = (p-1)*(q-1)
    while True:
        d = getPrime(256)  # Маленький d
        e = pow(d,-1,phi)
        if e.bit_length() == n.bit_length():
            break
    ciphertext = pow(plaintext, e, n)
    # ...
```

Если d < n^0.25, можно восстановить приватный ключ используя цепные дроби.

## Эксплуатация

### Предсказуемый ключ сессии
1. Генерируем все возможные ключи (100 вариантов из-за cycle_pos % 100)
2. Для каждого пользователя из attack_data пытаемся создать валидную сессию
3. Если сессия валидна, читаем биографию пользователя, где может быть флаг

### Слабое шифрование уровня 1
1. Получаем rec_id для уровня 1 из attack_data
2. Получаем шифротекст и token через /lookup
3. Находим S через дискретный логарифм: S = log_h(token) mod P
4. Перебираем все возможные internal_kb (0..P-1) и вычисляем k1, k2
5. Пробуем расшифровать, проверяя валидность padding

### Утечка ключа шифрования уровня 2
1. Получаем rec_id для уровня 2 из attack_data
2. Шифруем тестовые данные через /process, получаем ключ
3. Получаем шифротекст и nonce через /lookup
4. Расшифровываем используя полученный ключ

### Атака Винера на RSA уровня 3
1. Получаем rec_id для уровня 3 из attack_data
2. Получаем шифротекст c, n и e через /lookup
3. Применяем атаку Винера (цепные дроби) для нахождения d
4. Расшифровываем: m = c^d mod n

## Как фиксить

### Предсказуемый ключ сессии
- Использовать криптографически стойкий генератор случайных чисел (os.urandom)
- Генерировать ключ один раз при первом запуске и сохранять его

### Слабое шифрование уровня 1
- Использовать стандартные криптографические алгоритмы (AES)
- Увеличить размер модуля P или использовать другой подход к генерации ключей

### Утечка ключа шифрования уровня 2
- Не показывать ключ пользователю при шифровании
- Использовать разные ключи для разных пользователей или записей

### Атака Винера на RSA уровня 3
- Использовать больший приватный ключ d (рекомендуется d > n^0.292)
- Использовать стандартные рекомендации для генерации RSA ключей

