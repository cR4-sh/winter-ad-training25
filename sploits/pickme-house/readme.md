# PickMe House
## Базовый сценарий
Веб-приложение для шифрования данных с тремя уровнями безопасности. Пользователь может шифровать и расшифровывать данные, а также просматривать записи по ID.

### Все фичи
- Регистрация и авторизация
- Шифрование данных на трёх уровнях безопасности
- Расшифровка данных
- Просмотр записей по ID
- Профиль пользователя с биографией

## Архитектура
Flask веб-приложение с SQLite базой данных. Используется кастомный модуль SKZI для шифрования на разных уровнях.

## Уязвимости

### Предсказуемый ключ сессии

Ключ сессии генерируется детерминистически на основе глобального счётчика, который увеличивается при каждом вызове. Это позволяет предсказать ключи сессий.

```python
_counter = 0

def generate_secure_key(length=24):
    global _counter
    p_outer = 127
    p_middle = 251
    p_inner = 97
    
    g_outer = 3
    g_middle = 5
    g_inner = 6
    
    cycle_pos = _counter % 100
    _counter += 1
    
    key_bytes = []
    for i in range(length):
        inner_base = (cycle_pos * 7 + i * 13) % (p_inner - 1)
        inner_val = pow(g_inner, inner_base, p_inner)
        # ... детерменированная генерация
    return bytes(key_bytes)
```

При старте приложения ключ генерируется один раз:
```python
app.secret_key = SKZI.generate_secure_key(24)
```

Так как ключей всего около 500, можно перебрутать ключ сессии.


### Утечка ключа шифрования уровня 2

При шифровании на уровне 2 ключ показывается пользователю в ответе. Это позволяет расшифровать любые данные, зашифрованные на этом уровне.

```python
def encryption_security_clearance_level_2(plaintext: bytes, username: str = None) -> str:
    ctr = Counter.new(64, prefix=NONCE)
    cipher = AES.new(KEY, AES.MODE_CTR, counter=ctr)
    
    ciphertext = cipher.encrypt(plaintext)
    ct_hex = ciphertext.hex()
    key_hex = KEY.hex()  # Ключ показывается пользователю!
    nonce_hex = NONCE.hex()
    # ...
    return ct_hex, key_hex, nonce_hex, rec_id
```

### Атака Винера на RSA уровня 3

При шифровании на уровне 3 используется RSA с маленьким приватным ключом d (256 бит), что делает возможной атаку Винера.

```python
def encryption_security_clearance_level_3(plaintext: bytes, username: str = None) -> int:
    plaintext = bytes_to_long(plaintext)
    p = getPrime(1024)
    q = getPrime(1024)
    n = p * q
    
    phi = (p-1)*(q-1)
    while True:
        d = getPrime(256)  # Маленький d
        e = pow(d,-1,phi)
        if e.bit_length() == n.bit_length():
            break
    ciphertext = pow(plaintext, e, n)
    # ...
```

Если d < n^0.25, можно восстановить приватный ключ используя цепные дроби.

## Эксплуатация

### Предсказуемый ключ сессии
1. Генерируем все возможные ключи
2. Для каждого пользователя из attack_data пытаемся создать валидную сессию
3. Если сессия валидна, читаем биографию пользователя, где может быть флаг

### Слабое шифрование уровня 1
1. Получаем rec_id для уровня 1 из attack_data
2. Получаем шифротекст и token через /lookup
3. Генерируем все возможные ключи
4. Пробуем расшифровать, проверяя валидность padding


### Утечка ключа шифрования уровня 2
1. Получаем rec_id для уровня 2 из attack_data
2. Шифруем тестовые данные через /process, получаем ключ
3. Получаем шифротекст и nonce через /lookup
4. Расшифровываем используя полученный ключ

### Атака Винера на RSA уровня 3
1. Получаем rec_id для уровня 3 из attack_data
2. Получаем шифротекст c, n и e через /lookup
3. Применяем атаку Винера (цепные дроби) для нахождения d
4. Расшифровываем: m = c^d mod n

## Как фиксить

### Предсказуемый ключ сессии и level1
- Увеличить размер модуля P или использовать другой подход к генерации ключей

### Утечка ключа шифрования уровня 2
- Использовать разные ключи для разных пользователей или записей

### Атака Винера на RSA уровня 3
- Использовать больший приватный ключ d (рекомендуется d > n^0.292)

