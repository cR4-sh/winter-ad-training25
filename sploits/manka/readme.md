# Manka
## Базовый сценарий
Сервис для хранения секретов в памяти. Пользователь может сохранить секрет с паролем и получить его обратно, используя ключ (адрес в памяти) и пароль.

### Все фичи
- Сохранение секрета с паролем (получаем ключ - адрес в памяти)
- Получение секрета по ключу и паролю
- Скрытая функция чтения файлов (опция 3)

## Архитектура
Простое TCP-серверное приложение на C. Секреты хранятся в разделяемой памяти (mmap). Каждый секрет - структура с паролем (40 байт) и значением (40 байт).

## Уязвимости

### Отсутствие проверки длины пароля при сравнении

При проверке пароля используется `memcmp`, который сравнивает только то количество байт, которое было прочитано. Если пароль короче 40 байт, сравнение происходит только по прочитанным байтам.

```c
read_password = read_or_error(client, password, sizeof password,
    "Enter password: ", "Must be password\n");
if (read_password == -1) return -1;
password_end = strchr(password, '\n');
if (password_end) {
    read_password = password_end - password;
}
if (memcmp(secret->password, password, read_password) == 0) {
    write_cstr(client, "Corrent, here's your secret: ");
    write(client, secret->value, SECRET_SIZE);
    write_cstr(client, "\n");
}
```

Это позволяет брутфорсить первый символ пароля, передавая пароли длиной 1 байт.

### Чтение произвольной памяти через /proc/self/mem

В скрытой опции 3 можно указать путь к файлу и offset для чтения. Это позволяет читать `/proc/self/mem` с произвольным offset, что даёт доступ к любой памяти процесса.

```c
case 3: {
    char path[PATH_MAX] = {0};
    ssize_t read_path, read_offset, read_rsize;
    char offset_str[0x20] = {0};
    char rsize_str[0x20] = {0};
    size_t offset = 0;
    size_t rsize = 0;
    // ...
    fd = open(path, O_RDONLY);
    if (fd == -1) {
        write_cstr(client, "File doesn't exists!\n");
        close(client);
        return -1;
    }
    write_cstr(client, "Your file is: ");
    lseek(fd, offset, SEEK_SET);
    read(fd, buffer, rsize);
    write(client, buffer, rsize);
    // ...
}
```

### Использование адреса секрета как ключа для чтения соседних структур

Структуры `Secret` расположены последовательно в памяти. Если использовать адрес одного секрета как ключ для чтения другого, можно прочитать пароль из соседней структуры, а затем использовать его для чтения следующего секрета.

```c
case 2: {
    Secret *secret;
    ssize_t read_key;
    read_key = read_or_error(client, key, sizeof key,
        "Enter key: ", "Error, empty key\n");
    secret = (Secret *)strtoll(key, &(char *){key + read_key}, 16);
    // Нет проверки, что secret указывает на валидную структуру
    read_password = read_or_error(client, password, sizeof password,
        "Enter password: ", "Must be password\n");
    // ...
    if (memcmp(secret->password, password, read_password) == 0) {
        write(client, secret->value, SECRET_SIZE);
    }
}
```

## Эксплуатация

### Отсутствие проверки длины пароля
1. Получаем ключ (адрес) секрета из attack_data
2. Перебираем все возможные символы (цифры и буквы) как пароль длиной 1 байт
3. Когда сравнение пройдёт успешно, получаем секрет

### Чтение произвольной памяти через /proc/self/mem
1. Получаем адрес секрета из attack_data (это адрес в памяти)
2. Используем опцию 3 для чтения `/proc/self/mem` с offset равным адресу секрета
3. Читаем 80 байт (размер структуры Secret) и извлекаем значение секрета

### Использование адреса секрета как ключа
1. Создаём свой секрет с известным паролем, получаем его адрес
2. Вычисляем адрес следующей структуры (текущий адрес + 80 байт)
3. Используем адрес нашего секрета + 40 байт (где находится password следующей структуры) как ключ и наш пароль для чтения пароля следующего секрета
4. Используем адрес следующего секрета и прочитанный пароль для получения его значения

## Как фиксить

### Отсутствие проверки длины пароля
- Всегда сравнивать пароли фиксированной длины (40 байт)
- Использовать константно-временное сравнение (например, через XOR всех байт)

### Чтение произвольной памяти через /proc/self/mem
- Запретить чтение `/proc/self/mem` и других чувствительных файлов
- Использовать whitelist разрешённых путей
- Проверять, что offset не выходит за границы файла

### Использование адреса секрета как ключа
- Проверять, что указанный адрес действительно принадлежит массиву секретов
- Использовать индексы вместо указателей
- Добавить канарейки для обнаружения выхода за границы

